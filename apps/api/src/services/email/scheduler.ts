// Email scheduler for delayed/scheduled emails using BullMQ

import { PrismaClient } from '@prisma/client';
import { emailQueue } from './queue';
import * as emailService from './index';
import { getUnsubscribeUrl, canSendEmail } from './preferences';

const prisma = new PrismaClient();

interface ScheduleEmailOptions {
  emailType: string;
  recipientId: string; // userId or clientId
  recipientType: 'user' | 'client';
  scheduledFor: Date;
  data: Record<string, any>;
}

/**
 * Schedule an email to be sent at a specific time
 */
export async function scheduleEmail(options: ScheduleEmailOptions): Promise<string | null> {
  const { emailType, recipientId, recipientType, scheduledFor, data } = options;

  // Check if the recipient has opted out
  const canSend = await canSendEmail(emailType, {
    userId: recipientType === 'user' ? recipientId : undefined,
    clientId: recipientType === 'client' ? recipientId : undefined,
  });

  if (!canSend) {
    console.log(`[SCHEDULER] Skipping ${emailType} for ${recipientId} - opted out`);
    return null;
  }

  const delay = Math.max(0, scheduledFor.getTime() - Date.now());

  // Queue the email with a delay
  const result = await emailQueue.enqueue({
    to: data.to,
    subject: data.subject || `VERGO - ${emailType}`,
    html: '', // Will be generated by the worker
    emailType: emailType as any,
    userId: recipientType === 'user' ? recipientId : undefined,
    clientId: recipientType === 'client' ? recipientId : undefined,
    scheduledAt: scheduledFor,
  });

  if (!result.success) {
    console.error('[SCHEDULER] Failed to schedule email:', result.error);
    return null;
  }

  // Store in database for tracking
  try {
    await prisma.scheduledEmail.create({
      data: {
        jobId: result.id,
        scheduledFor,
        emailType,
        recipientId,
        subject: data.subject || emailType,
        metadata: data,
        status: 'SCHEDULED',
      },
    });
  } catch (error) {
    console.error('[SCHEDULER] Failed to store scheduled email record:', error);
  }

  console.log(`[SCHEDULER] Email scheduled: ${emailType} for ${recipientId} at ${scheduledFor.toISOString()}`);
  return result.id;
}

/**
 * Cancel a scheduled email
 */
export async function cancelScheduledEmail(jobId: string): Promise<boolean> {
  try {
    // Update database record
    await prisma.scheduledEmail.update({
      where: { jobId },
      data: { status: 'CANCELLED' },
    });

    console.log(`[SCHEDULER] Cancelled scheduled email: ${jobId}`);
    return true;
  } catch (error) {
    console.error('[SCHEDULER] Failed to cancel scheduled email:', error);
    return false;
  }
}

/**
 * Get scheduled emails for a recipient
 */
export async function getScheduledEmails(recipientId: string) {
  return prisma.scheduledEmail.findMany({
    where: {
      recipientId,
      status: 'SCHEDULED',
    },
    orderBy: { scheduledFor: 'asc' },
  });
}

// ============================================
// CONVENIENCE SCHEDULERS
// ============================================

/**
 * Schedule a quote follow-up email (3 days after quote sent)
 */
export async function scheduleQuoteFollowup(data: {
  clientId: string;
  clientEmail: string;
  clientName: string;
  eventType: string;
  eventDate: string;
}): Promise<string | null> {
  const scheduledFor = new Date();
  scheduledFor.setDate(scheduledFor.getDate() + 3); // 3 days later

  const unsubscribeUrl = await getUnsubscribeUrl({ clientId: data.clientId });

  return scheduleEmail({
    emailType: 'quote-followup',
    recipientId: data.clientId,
    recipientType: 'client',
    scheduledFor,
    data: {
      to: data.clientEmail,
      subject: 'Following up on your VERGO quote',
      name: data.clientName,
      eventType: data.eventType,
      date: data.eventDate,
      unsubscribeUrl,
    },
  });
}

/**
 * Schedule an application review reminder (48 hours after submission)
 */
export async function scheduleApplicationReviewReminder(data: {
  applicantName: string;
  applicationId: string;
  roles?: string[];
}): Promise<string | null> {
  const scheduledFor = new Date();
  scheduledFor.setHours(scheduledFor.getHours() + 48); // 48 hours later

  return scheduleEmail({
    emailType: 'application-review-reminder',
    recipientId: 'admin', // Goes to admin
    recipientType: 'user',
    scheduledFor,
    data: {
      to: 'wrobb@vergoltd.com',
      subject: 'Application Review Reminder',
      applicantName: data.applicantName,
      applicationId: data.applicationId,
      roles: data.roles,
    },
  });
}

/**
 * Schedule a shift reminder (24 hours before shift)
 */
export async function scheduleShiftReminder(data: {
  userId: string;
  userEmail: string;
  userName: string;
  jobTitle: string;
  location: string;
  eventDate: Date;
}): Promise<string | null> {
  const scheduledFor = new Date(data.eventDate);
  scheduledFor.setHours(scheduledFor.getHours() - 24); // 24 hours before

  // Don't schedule if already past
  if (scheduledFor.getTime() <= Date.now()) {
    console.log('[SCHEDULER] Shift reminder time already passed, skipping');
    return null;
  }

  const unsubscribeUrl = await getUnsubscribeUrl({ userId: data.userId });

  return scheduleEmail({
    emailType: 'shift-reminder',
    recipientId: data.userId,
    recipientType: 'user',
    scheduledFor,
    data: {
      to: data.userEmail,
      subject: `Shift Reminder - ${data.jobTitle}`,
      name: data.userName,
      jobTitle: data.jobTitle,
      location: data.location,
      eventDate: data.eventDate,
      unsubscribeUrl,
    },
  });
}
